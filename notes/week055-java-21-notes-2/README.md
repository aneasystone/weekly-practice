# WEEK055 - Java 21 初体验（二）

在 [上一篇笔记](../week050-java-21-notes/README.md) 中，我们学习了 Java 21 中前 5 个重要特性：

* 430: [String Templates (Preview)](https://openjdk.org/jeps/430)
* 431: [Sequenced Collections](https://openjdk.org/jeps/431)
* 439: [Generational ZGC](https://openjdk.org/jeps/439)
* 440: [Record Patterns](https://openjdk.org/jeps/440)
* 441: [Pattern Matching for `switch`](https://openjdk.org/jeps/441)

接下来，我们将继续学习后面的 5 个特性：

* 442: [Foreign Function & Memory API (Third Preview)](https://openjdk.org/jeps/442)
* 443: [Unnamed Patterns and Variables (Preview)](https://openjdk.org/jeps/443)
* 444: [Virtual Threads](https://openjdk.org/jeps/444)
* 445: [Unnamed Classes and Instance Main Methods (Preview)](https://openjdk.org/jeps/445)
* 446: [Scoped Values (Preview)](https://openjdk.org/jeps/446)

## 外部函数和内存 API（第三次预览版本）

**外部函数和内存 API（Foreign Function & Memory API，简称 FFM API）** 是 Java 17 中首次引入的一个重要特性，经过了 [JEP 412](https://openjdk.org/jeps/412) 和 [JEP 419](https://openjdk.org/jeps/419) 两个孵化版本，以及 [JEP 424](https://openjdk.org/jeps/424)  和 [JEP 434](https://openjdk.org/jeps/434) 两个预览版本，在 Java 21 中，这已经是第三个预览版本了。

FFM API 由两大部分组成：**外部函数接口（Foreign Function Interface，简称 FFI）** 和 **内存 API（Memory API）**，FFI 用于实现 Java 代码和外部代码之间的相互操作，而 Memory API 则用于安全地管理堆外内存。FFM API 的引入为 Java 在人工智能、数据科学等领域的应用提供了更多的可能性，有望加速 Java 在这些领域的发展和应用。

### 使用 JNI 调用外部函数

在引入外部函数之前，如果想要实现 Java 调用外部函数库，我们需要借助 **JNI (Java Native Interface)** 来实现。下面的代码是一个使用 JNI 调用外部函数的例子：

```
public class JNIDemo {
    static {
        System.loadLibrary("JNIDemo");
    }

    public static void main(String[] args) {
        new JNIDemo().sayHello();
    }

    private native void sayHello();
}
```

其中 `sayHello` 函数使用了 `native` 修饰符，表明这是一个本地方法，该方法的实现不在 Java 代码中。这个本地方法可以使用 C 语言来实现，我们首先需要生成这个本地方法对应的 C 语言头文件：

```
$ javac -h . JNIDemo.java
```

`javac` 命令不仅可以将 `.java` 文件编译成 `.class` 字节码文件，而且还可以生成本地方法的头文件，参数 `-h .` 表示将头文件生成到当前目录。这个命令执行成功后，当前目录应该会生成 `JNIDemo.class` 和 `JNIDemo.h` 两个文件，`JNIDemo.h` 文件内容如下：

```
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class JNIDemo */

#ifndef _Included_JNIDemo
#define _Included_JNIDemo
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     JNIDemo
 * Method:    sayHello
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_JNIDemo_sayHello
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
```

正如我们所看到的，在这个头文件中定义了一个名为 `Java_JNIDemo_sayHello` 的函数，这个名称是根据包名、类名和方法名自动生成的。有了这个自动生成的头文件，我们就可以在 C 语言里实现这个这个方法了，于是接着创建一个 `JNIDemo.c` 文件，编写代码：

```
#include "jni.h"
#include "JNIDemo.h"
#include <stdio.h>

JNIEXPORT void JNICALL Java_JNIDemo_sayHello(JNIEnv *env, jobject jobj) {
    printf("Hello World!\n");
}
```

这段代码很简单，直接调用标准库中的 `printf` 输出 `Hello World！`。

然后使用 gcc 将这个 C 文件编译成动态链接库：

```
$ gcc -I${JAVA_HOME}/include -I${JAVA_HOME}/include/darwin -dynamiclib JNIDemo.c -o libJNIDemo.dylib
```

这个命令会在当前目录下生成一个名为 `libJNIDemo.dylib` 的动态链接库文件，这个库文件正是我们在 Java 代码中通过 `System.loadLibrary("JNIDemo")` 加载的库文件。

> 注意这里我用的是 Mac 操作系统，其他操作系统的命令略有区别。
>
> Linux 系统：
> ```
> $ gcc -I${JAVA_HOME}/include -I${JAVA_HOME}/include/linux -shared JNIDemo.c -o libJNIDemo.so
> ```
>
> Windows 系统：
> ```
> $ gcc -I${JAVA_HOME}/include -I${JAVA_HOME}/include/win32 -shared JNIDemo.c -o JNIDemo.dll
> ```

至此，我们就可以运行这个 Hello World 的本地实现了：

```
$ java -cp . -Djava.library.path=. JNIDemo
```

以上步骤演示了如何使用 JNI 调用外部函数，这只是 JNI 的一个简单示例，更多 JNI 的高级功能，比如实现带参数的函数，在 C 代码中访问 Java 对象或方法等，可以参考 [Baeldung 的这篇教程](https://www.baeldung.com/jni)。

### 外部函数接口（Foreign Function Interface）

FFI 实现了对外部函数库的原生接口，从而可以使 Java 在与 C、C++ 等语言编写的库集成时更加方便和高效，可以理解为 JNI 的平替。

### 使用 `ByteBuffer` 和 `sun.misc.Unsafe` 访问堆外内存

### 内存 API（Memory API）

https://openjdk.org/jeps/442

## 未命名模式和变量（预览版本）

https://openjdk.org/jeps/443

## 虚拟线程

https://openjdk.org/jeps/444

## 未命名类和实例的 Main 方法（预览版本）

https://openjdk.org/jeps/445

## 作用域值（预览版本）

https://openjdk.org/jeps/446

## 参考

* [Guide to JNI (Java Native Interface)](https://www.baeldung.com/jni)
* [The Arrival of Java 21](https://blogs.oracle.com/java/post/the-arrival-of-java-21)
* [Java 版本历史](https://zh.wikipedia.org/wiki/Java%E7%89%88%E6%9C%AC%E6%AD%B7%E5%8F%B2)
* [Java 9 - 21：新特性解读](https://www.didispace.com/java-features/)
* [Java 21 新特性概览](https://javaguide.cn/java/new-features/java21.html)
* [JDK11 升级 JDK17 最全实践干货来了 | 京东云技术团队](https://my.oschina.net/u/4090830/blog/10142895)
* [Java 21：下一个LTS版本，提供了虚拟线程、记录模式和模式匹配](https://www.infoq.cn/article/zIiqcmU8hiGhmuSAhzwb)
* [Hello, Java 21](https://spring.io/blog/2023/09/20/hello-java-21/)
* [深入剖析Java新特性](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Java%E6%96%B0%E7%89%B9%E6%80%A7/)
* [浅析一下Java FFM API(Project Panama)](https://zhuanlan.zhihu.com/p/648108631)
* [Java21新特性教程](https://www.panziye.com/back/10563.html)
* [结构化并发 | 楚权的世界](http://chuquan.me/2023/03/11/structured-concurrency/)
* [聊一聊Java 21，虚拟线程、结构化并发和作用域值](https://cloud.tencent.com/developer/article/2355577)
* [千呼万唤始出来：Java终于发布了"协程"--虚拟线程!](https://www.yuanjava.cn/posts/virtual-thread/)
* [JNI的运行机制](https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%8b%86%e8%a7%a3Java%e8%99%9a%e6%8b%9f%e6%9c%ba/32%20%20JNI%e7%9a%84%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6.md)

## 更多

### JDK Projects

* [Project Panama](https://openjdk.org/projects/panama/) - Interconnecting JVM and native code
* [Project Amber](https://openjdk.org/projects/amber/) - Explore and incubate smaller, productivity-oriented Java language features
* [Project Loom](https://wiki.openjdk.org/display/loom) - Supporting easy-to-use, high-throughput lightweight concurrency and new programming models on the Java platform.
